

Java 8 Features 

1. Lambda Expression 
2. Functional Interface 
3.Default Method 
4.Static Method in interface 
5. Predicate -- predefine FI
6. Function  --predefine FI
7.Consumer --- predefine FI
8. :: Method Refernce & Consturctor refernce 
9. Stream API -- to write more concise code 
10. Date and Time API (JODA API )


Why we need 1.8 -
1. to simplify programming
2. to utilize functional programming benefit in java
3. to enable parallel processing 

1. Advantage Lambda Expression-
================================
To enable functional programming in java 
To write more readable , maintainable & concise code 
To use API's very easily and effetively 
To enable Parallel processing 

from lambda expression we can access class label variable 
from lambda expression we can access local variable but local variable which are refernced with lambda expression is final , within lambda expression or outside lambda expression
you can't change the value , if you wan to change it , it will throw class class cast exception 

 

Predicate --
==================
Predicate return type always boolean value 
interface Predicate<T>
{
boolean test(T t)
}  //it will take some input , perform operation and return boolean value .

Function--
====================
interface function< t ,r> // 2 arguments - 1 is input argument and another is return type
{
 r apply (t) 
}

whether it may be function or predicate it must return some value 

Consumer --
=============
sometime i want to give some input and perform some operation but don't want return 

interface consumer<t>
{
void accept (t)
}
Supplier---
======================
Supplier<R> - return type // never going to take anything , always return something 
{
R get() // won't take any argument 
}


Stream --
================
Stream we use to process object from collection and perform bulk operation 
Stream s =c.stream(); / default method inside collection 
filter(Predicate<t>)/ filter some element from stream 
map(function <t,r> f) /every element present in stream i want to create equivalent new group of object 

-------------
collect () - collect value from stream
count() - count number of element in stream 
sorted() - d.n.s
sorted(comparator c)- customize sorting order 
min(comparator c)
max(comparator c)
forEach() 
toArray - to copy array
stream.of()- group of value and array 

Date&Time Api-
=========================
LocalDate date=LocalDate.now() / which return current system date 
LocalTime time =LocalTime.now()/ which return current system time 

int dd=date.getDayOfMonth();
int mm =date.getMonthValue();
int yyyy=date.getYear();

Java.time - Package 



Stream Api Operations===
----------------------------
Intermediate operations - Transform stream into another stream
======================
1. Filter - it is goinf to return same number of elements of list or lesser 
2. map - convert each and every element to another element by using some operation 
ex- 
List<String> words =Arrays.asList("apple","Bananna","cherry");
List<String> result = words.stream().map(String::toUppercase).collect(Collectors.toList());
3. Flat Map - if you have list of list of string you can flatten them into single list string 
4. distinct - remove duplicate element 
5.sorted - sort element in string 
6.peek - debuging propose ,whatever operation you perform in stream it won't reflect 
7.limit - set a limit while fetching  ex - fetch first 3 elements 
List<Integer> num = Arrays.asList("1,4,8,3,2,9");
List<Integer> res= num.stream.limit(3).collect(Collectors.toList());
8.Skip - skip the element ex - skip the first 4 elements and print the rest 


Terminal Operations ==
------------------------
It produce result and terminate the stream 

1. forEach - used to do something with each and every elements in stream 
2. collect -
3. reduce - used to perform reduction on the elements - perform the operation unit the list have one single value 
4. allmatch - used to check if all elements in the stream satisfy a given predicate , it return true if every element in the stream matches predicate , and false otherwise
5. anymatch -at least one element in stream matches a given predicate , it return true and stop further process , if no element match return false 
6. nonmatch - no element in stream match predicate 
7.findfirst - used to retrive the first element if the given condition satisfy , return type always optional
8.findAny - retrive any element that matches  a given condition 
9. max - find the max element , return optional 
10. min - find the min element , return optional
11.toArray - convert the list into array 

Collectors ===
---------------
1. joining - concate element of stream into single string 
2. groupingBy- 



GIT--
------
DVCS - Distributed Version Control System 
CVCS - Centralized Versio Control System 

Working Directory - Where you write your code 
Staging Area - here we are giving it to git to manage / git add filename 	

git diff - if want to check what you added in file use this command and also use this command in working directory
git diff --staging - you can check changes after moving the file to staging area 

readme.md - markdown 

Git remove - git rm --cached filename // delete file from git (after adding and commiting file if want to delete from staging )

git push origin main /origin means the origin where you are pushing and fetching 

Tagging 

Branch - git checkout (old ) / git switch (new ) /
for creating branch - git checkout -b branchname 
going back to previous branc - git switch -
delete branch - git branch -d branchname 

git merge - suppose i want want merge my feature branch into main branch . do git checkout come to main branch then do git merge feature1
